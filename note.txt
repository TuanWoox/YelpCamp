<input type="text" id="title" name="campground[title]">
=> this is used to group content together under campground when we send the form
render => is used to render things in views
redirect => is used to change the website link not the views

SECTION 41: 
ejs-mate is a tool helps us to create boilerplate tempalte ( a level up compare to partial)
//We dont need to back away, just specify which folder the layout in!
<% layout('layouts/boilerplate') -%>
//We need to back away if that is in another folder
includeing partial: <%- include('../partials/navbar') %>
difference between partial and ejs-mate:
With partials, you add the whole block at once, without customizing it; layout on the other hand lets you customize the text within that boilerplate, not only add it.
<div class="row">
    <div class="col-md-4"> => take 1/3 of the row


SECTION 43:
<form class="row g-3 needs-validation" novalidate>
=>For custom Bootstrap form validation messages, youâ€™ll need to add the novalidate boolean attribute to your <form>. This disables the browser default feedback tooltips, but still provides access to the form validation APIs in JavaScript
Adding: Utils with 2 js file is CatchAsyncs ( helping us to catch async error) and ExpressError (our custom defining error class)
Adding: Error template
Adding: validateSchema ( this is a joi schema for detecting error pattern in javascript)
The app.get('*') doesnt conflict with the app.use to handle error! Because when we throw an error =>
it will look for app.use with 4 parameter!!!
JOI : a JavaScript validating tool
//Explain for this code: First we pass in a object ( that is request.body) => in that request.body
it must have campground ( is also a object)!
const campgroundSchema =Joi.object({
        campground: Joi.object({
            title: Joi.string().require(),
            price: Joi.number().required().min(0),
            location: Joi.string().required(),
            description: Joi.string().required()
        }).require()
    })

THE IMAGE EXPLAINATION:
-We dont get new images for the index show page because the cache of the browser and the link block us from getting new image everytime!

SECTION 46:
module.exports.reviewSchema = Joi.object({
    review: Joi.object({
        rating: Joi.number().required().min(1).max(5),
        body: Joi.string().required()
    }).required()
})
If we dont have .required() the whole object => the validation will still pass if the review object is missing


SECTION49:
express router would like to keep param seperately, like the param in the prefix 
wont be in the route file => to have that => we need to specify an option
mergeParams : true
The purpose of serving static file:
These things are to be made available publicly because the browser should be able to access it and process in client side. so for this and images, css, js and docs as well, we use public fonder.

or putting it simple, those static (constant) files which are accessed by the browser (not server) are kept in the public directory.

Note If both expires and maxAge are set in the options, then the last one defined in the object is what is used.
Note The expires option should not be set directly; instead only use the maxAge option.

The connect-flash middleware is used to store flash messages in the session, which are then accessible in the req.flash object. When you configure connect-flash in your main app.js file and add it to your Express app, it makes the flash functionality available throughout your application, including in your routers.
By setting up express-session and connect-flash in app.js, every request passing through your application has access to req.flash. This includes requests handled by routers defined in separate files.

Flash is depended upon sessions, because it stores information in session. => 

Yes, you need to install and use express-session alongside connect-flash in a Node.js application.

SECTION51:
-Passport is a middleware for Node.js that provides a simple 
and extensible authentication framework. It supports various authentication strategies, allowing for a wide range of use cases, from simple local logins to complex OAuth integrations.
-Passport-local is one of the strategies available for Passport. It is designed for local authentication using a username and password.
-Passport-local-mongoose is a Mongoose plugin that simplifies the implementation of Passport-local authentication.
Passport and passport-local and passport-local-mongoose combine all together 

In the newest version of passport, once you logged in => the session is cleared => we use a middleware and local.res to 
return to the page they are using before!



SECTION52:
  const campground =await Campground.findById(req.params.id).populate({
        path: 'reviews',
        populate: {
            path: 'author'
        }
    }).populate('author');
=> This used to nest to populate the object we populate!!!
So at this section we are basically done with our app hehe => follow this patterns for practicing more!

SECTION 53:
New patterns: Controllers
=> Straight point is that we move all the controller into separate file into function!!!
Controllers is the hearts of our application!

router.route('/:id')
.get(catchAsync(campgControl.showCampground))
.put(isLoggedIn,isAuthor,validateCampground,catchAsync(campgControl.updateCampground))
.delete(isLoggedIn,isAuthor,catchAsync(campgControl.deleteCampground))
this router.route helps us to group things that is the same url but different verb!

starability allows us to use star for reviewing!!!

SECTION54:
It is not a good idea to store image in database => we store in some app like Cloudinary and AWS 
=> It will send back url and the database will store that url for us!
The multer middleware: this middleware helps us to parse the multipart/form-data
becasue Express.js itself does not provide built-in support for parsing multipart/form-data directly.!
Multer adds a body object and a file or files object to the request object. The body object contains the values of the text fields of the form, the file or files object contains the files uploaded via the form.
https://github.com/expressjs/multer
DONT LET NOBODY SEE THE API KEY AND THE API SECRET!!! THEY COULD USE IT AND MESS UP 
An .env file is used to store environment variables in key-value pairs. These variables are often configuration settings that your application needs to run, such as database credentials, API keys, or other sensitive information that you don't want to hardcode into your application's source code
https://www.npmjs.com/package/dotenv
multer-storage-cloudinary helps us to store the images! => install cloudinary and multer-storage-cloudinary
When returning an object literal with an implicit return, you need to wrap the object in parentheses to avoid syntax errors.
Should keep in mind that we need to limit the amount of images!!!
In MongoDB with Mongoose, a virtual is a property that you define in your Mongoose schema but is not stored in the database. Instead, it's a property that's computed dynamically based on other fields in the document.
all package:
multer: needs for parsing multimedia
cloudinary: needs for config and have some API
multer-storage-cloudinary : needs for accessing and upload images to cloudinary
We need to put multer first otherwise req.body wont be parse! but in that way multer will upload image even tho the campground is invalid!


SECTION55:
Geocoding is the process of converting addresses (like "1600 Amphitheatre Parkway, Mountain View,
CA") into geographic coordinates (like latitude 37.423021 and longitude -122.083739), which can be 
used to place markers on a map, analyze spatial data, or perform various geographic information
system (GIS) functions. It involves parsing and interpreting address data to match it to geographic coordinates, 
making it a crucial component in location-based services, mapping applications, and spatial analysis
we have mapbox nodejs package!
const geoData = await geoCoder.forwardGeocode({
        query: req.body.campground.location,
        limit:1
    }).send()
    res.send(geoData.body.features[0].geometry.coordinates);
[
    109.24946,
    13.550355
] => longitude and latitude
we need to follow the GeoJson patterns => because mongo have some operations for it and later we could use that!
So the javascripts wont be paste like html and other thing so it can look for ejs 
but we can create constant in a script in it => it will link with the js file 
<script>
    const mapToken = '<%-process.env.MAPBOX_TOKEN%>';
</script>
<script src="/javascripts/showPageMap.js"></script>

SECTION56:
https://docs.mapbox.com/mapbox-gl-js/example/cluster/
we need to also await for the async function!
mapboxgl.accessToken = mapToken;
const map = new mapboxgl.Map({
        container: 'map', // container ID
        style: 'mapbox://styles/mapbox/streets-v12', // style URL
        center: campground.geometry.coordinates, // starting position [lng, lat]
        zoom: 12, // starting zoom
});

new mapboxgl.Marker()
    .setLngLat(campground.geometry.coordinates)
    .setPopup(
        new mapboxgl.Popup({offset:25})
        .setHTML(
            `<h3>${campground.title}</h3>
            <p>${campground.location}</p>
            `
        )
    )
    .addTo(map);

if we want to add different maps => we need to specified different container

When we use cluster map in mapbox
=>
"features": [
        {
            "type": "Feature",
            "properties": {
                "id": "ak16994521",
                "mag": 2.3,
                "time": 1507425650893,
                "felt": null,
                "tsunami": 0
            },
            "geometry": {
                "type": "Point",
                "coordinates": [
                    -151.5129,
                    63.1016,
                    0
                ]
            }
        },
mapbox will accept a properties named features => that have a list of object which have geometry and properties is other thing!

SECTION57:
